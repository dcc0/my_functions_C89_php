; Найдено здесь (Found here): https://mrempy.medium.com/assembly-16-bits-printing-strings-a114c72f6e43
; 1) Добавлен цвет фона
; 2) Добавлено обновление экрана
; 3) Добавлено умножение чисел 3 на 20 по нажатию клавиши 0
; Команда сборки и выполнения
; nasm cat_on_boot.asm -o cat_on_boot.bin;  qemu-system-x86_64 cat_on_boot.bin
ORG 0x7C00    ; Смещение (в загрузочный сектор - MBR)
BITS 16             ; 16 битный режим
       mov   ax,3 ; Загрузим новый цвет в видеопамять
       int 0x10
       push 0xb800
       pop   es
       xor   di,di      ;// ES:DI = указатель на в/буфер (приёмник для stosw)
       mov   cx,80*25   ;// кол-во символов в буфере
       mov   ax,0x7020  ;// атрибут = цвет фона(7), цвет текста(0), символ(20=пробел)
       rep   stosw      ;// записать АХ в ES:DI, по длине СХ
       mov di,  msg
       call PrintStr ; Вызываем вывод на экран, для каждого сообщения (функция)

jmp if_char
first:
        mov ax, 03            ; Обновим экран
        int 10h
        mov al, 3             ; Добавим 3 в al
        mov bl, 20            ; Добавим 20 в al
        mul bl                ; Умножим (результат в dl)
        mov di, 4             ; Для инкремента

loop:                         ;Начало цикла
        dec di                ;Декремент, чтобы  записать все значения остатка в stroka
        mov bx, 10            ;Делитель. Запишем  в цикл, чтобы вернуть ему значение на новой итерации
        xor dx, dx            ;Обнулим остаток
        div bx                ;Делим
        add dx, 30h           ;Добавим в остаток 0, равносильно add edx, '0'
        mov  [plus + di], dl  ;Пишем в строку остаток в обратном порядке.
        cmp di,  0            ;Выходим
jne loop

        mov di, plus
        call PrintStr       ; PrintStr(si);

        int 10h
;Ожидание клавиши
if_char:                     ;закр. метка
        mov ah, 0            ;вызов обработки клавиши
        int 16h              ;вызываем 16 прерывание функции 0h
        cmp ah, 0Bh          ;код клавиши '0'
        jz first             ; Если нажали 0, то загружаем кошку
jne if_char                  ;Ждём нажатия
jmp $
PrintStr:                    ; Вывод сообщения (функция)
        mov ah, 0x0E         ;Установим режим телетайп
        mov al, [di]         ;Добавим  элемент массива в al
        psloop:              ;Цикл
        int 0x10             ;Системный вызов BIOS
        inc di               ;инкремент
        mov al, [di]         ;пишем след. значение
        cmp al, 0            ;Если равен 0, выходим
        jne psloop           ;Возврат в цикл
    ret
ret

        msg db  "Press Key 0. Umnojim 3 na 20", 13, 10, 0
        plus db 4, 13, 10, 0
        times 510 - ($-$$) db 0     ;Заполняем нулями до 510 байта
        dw 0xAA55                   ; Последние два байта сектора, к которым обращается BIOS
